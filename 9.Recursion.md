# Recursion
## DAY 55
### [Implement Pow(x,n)](https://leetcode.com/problems/powx-n/description/)
```java
class Solution {
    public double myPow(double x, int n) {
        return Math.pow(x,n);
    }
}
```
```java
class Solution {
    public double myPow(double x, int n) {
        // Handle negative exponents by inverting x and making n positive.
        // We use a long to store 'n' to safely handle the edge case 
        // when n is Integer.MIN_VALUE (-2,147,483,648), which has no positive counterpart 
        // in an 'int' (Integer.MAX_VALUE is only 2,147,483,647).
        long N = n; 
        
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }

        double result = 1.0;
        double currentProduct = x;
        
        // Loop while the exponent N is greater than 0
        while (N > 0) {
            
            // If the last bit of N is 1 (i.e., N is odd)
            // This means we need to multiply the result by the current power of x
            if ((N & 1) == 1) { 
                result = result * currentProduct;
            }
            
            // Square the current product for the next iteration
            // This is the "squaring" part of the algorithm
            currentProduct = currentProduct * currentProduct;
            
            // Halve the exponent (equivalent to N = N / 2)
            N = N >> 1; 
        }
        
        return result;
    }
}
```
## DAY 56
### [Count Good Numbers](https://leetcode.com/problems/count-good-numbers/description/)
```java
class Solution {
    static final int MOD = 1_000_000_007;

    public int countGoodNumbers(long n) {
        return (int) (countGoodNumbersRecursive(n, 0) % MOD);
    }

    private long countGoodNumbersRecursive(long n, long currentIndex) {
        if (currentIndex == n) {
            return 1;
        }
        
        long result = 0;
        
        if (currentIndex % 2 == 0) {
            result = (5 * countGoodNumbersRecursive(n, currentIndex + 1));
        } else { 
            result = (4 * countGoodNumbersRecursive(n, currentIndex + 1));
        }

        return result % MOD;
    }
}
```
#### Optimized Approach
```java
class Solution {
    private final int MOD = 1_000_000_007;

    public int countGoodNumbers(long n) {
        long countOfFives = (n + 1) / 2; 
        long countOfFours = n / 2;

        long resultFive = power(5, countOfFives);
        long resultFour = power(4, countOfFours);

        return (int) ((resultFive * resultFour) % MOD);
    }

    private long power(long base, long exponent) {
        long result = 1;
        base %= MOD; 

        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % MOD;
            }
            base = (base * base) % MOD;
            exponent /= 2;
        }
        return result;
    }
}
```
