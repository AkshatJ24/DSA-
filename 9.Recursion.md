# Recursion
## DAY 55
### [Implement Pow(x,n)](https://leetcode.com/problems/powx-n/description/)
```java
class Solution {
    public double myPow(double x, int n) {
        return Math.pow(x,n);
    }
}
```
```java
class Solution {
    public double myPow(double x, int n) {
        // Handle negative exponents by inverting x and making n positive.
        // We use a long to store 'n' to safely handle the edge case 
        // when n is Integer.MIN_VALUE (-2,147,483,648), which has no positive counterpart 
        // in an 'int' (Integer.MAX_VALUE is only 2,147,483,647).
        long N = n; 
        
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }

        double result = 1.0;
        double currentProduct = x;
        
        // Loop while the exponent N is greater than 0
        while (N > 0) {
            
            // If the last bit of N is 1 (i.e., N is odd)
            // This means we need to multiply the result by the current power of x
            if ((N & 1) == 1) { 
                result = result * currentProduct;
            }
            
            // Square the current product for the next iteration
            // This is the "squaring" part of the algorithm
            currentProduct = currentProduct * currentProduct;
            
            // Halve the exponent (equivalent to N = N / 2)
            N = N >> 1; 
        }
        
        return result;
    }
}
```
## DAY 56
### [Count Good Numbers](https://leetcode.com/problems/count-good-numbers/description/)
```java
class Solution {
    static final int MOD = 1_000_000_007;

    public int countGoodNumbers(long n) {
        return (int) (countGoodNumbersRecursive(n, 0) % MOD);
    }

    private long countGoodNumbersRecursive(long n, long currentIndex) {
        if (currentIndex == n) {
            return 1;
        }
        
        long result = 0;
        
        if (currentIndex % 2 == 0) {
            result = (5 * countGoodNumbersRecursive(n, currentIndex + 1));
        } else { 
            result = (4 * countGoodNumbersRecursive(n, currentIndex + 1));
        }

        return result % MOD;
    }
}
```
#### Optimized Approach
```java
class Solution {
    private final int MOD = 1_000_000_007;

    public int countGoodNumbers(long n) {
        long countOfFives = (n + 1) / 2; 
        long countOfFours = n / 2;

        long resultFive = power(5, countOfFives);
        long resultFour = power(4, countOfFours);

        return (int) ((resultFive * resultFour) % MOD);
    }

    private long power(long base, long exponent) {
        long result = 1;
        base %= MOD; 

        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % MOD;
            }
            base = (base * base) % MOD;
            exponent /= 2;
        }
        return result;
    }
}
```
## DAY 57
### [Generate Paranthesis](https://leetcode.com/problems/generate-parentheses/description/)
```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        backtrack("",0,0,n,res);
        return res;
    }
    static void backtrack(String s, int open, int close, int n, List<String> res){
        if(s.length() == 2 * n){
            res.add(s);
            return;
        }
        if(open < n){
            backtrack(s + "(",open + 1, close, n, res);
        }
        if(close < open) {
            backtrack(s + ")",open , close + 1, n, res);
        }
    }
}
```
## DAY 58
### [Subsets](https://leetcode.com/problems/subsets/description/)
```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    
    private List<List<Integer>> result;
    
    public List<List<Integer>> subsets(int[] nums) {
        this.result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        solve(0, nums, currentSubset); 
        return this.result;
    }
    
    private void solve(int i, int[] nums, List<Integer> currentSubset) { 
        
        if (i == nums.length) {
            this.result.add(new ArrayList<>(currentSubset)); 
            return;
        }
        
        // PICK
        currentSubset.add(nums[i]);
        solve(i + 1, nums, currentSubset);
        
        // BACKTRACK
        currentSubset.remove(currentSubset.size() - 1);
        
        // DON'T PICK
        solve(i + 1, nums, currentSubset);
    }
}
```
## DAY 59
### [Combination Sum](https://leetcode.com/problems/combination-sum/description/)
```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        dfs(0, new ArrayList<>(), 0, candidates, target);
        return res;
    }
    private void dfs(int i, List<Integer> cur, int total, int[] candidates, int target) {   
        if (total == target) {
            res.add(new ArrayList<>(cur));
            return;
        }
        if (i >= candidates.length || total > target) {
            return;
        }
        // PICK
        cur.add(candidates[i]);
        dfs(i, cur, total + candidates[i], candidates, target);
        cur.remove(cur.size() - 1);
        // DON'T PICK
        dfs(i + 1, cur, total, candidates, target);
    }
}
```
## DAY 60
### [Subsets II](https://leetcode.com/problems/subsets-ii/description/)
```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        findSubsets(0, nums, new ArrayList<>(), ans);
        return ans;
    }
    public static void findSubsets(int ind, int[] nums, List<Integer> ds, List<List<Integer>> ans){
        ans.add(new ArrayList<>(ds));
        for(int i = ind; i < nums.length; i++){
            if(i!=ind && nums[i] == nums[i-1]) continue; 
            ds.add(nums[i]); 
            findSubsets(i+1, nums, ds, ans); 
            ds.remove(ds.size() - 1);
        }
    }
}
```
## DAY 61 
### [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/description/)
```java
class Solution {
    
    private List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        dfs(0, new ArrayList<>(), 0, candidates, target);
        return res;
    }

    private void dfs(int i, List<Integer> cur, int total, int[] candidates, int target) {
        
        if (total == target) {
            res.add(new ArrayList<>(cur));
            return;
        }

        if (i >= candidates.length || total > target) {
            return;
        }

        // PICK
        cur.add(candidates[i]);
        dfs(i + 1, cur, total + candidates[i], candidates, target);
        cur.remove(cur.size() - 1);
        
        while(i+1 < candidates.length && candidates[i] == candidates[i+1]) ++i;

        // DON'T PICK
        dfs(i + 1, cur, total, candidates, target);
    }
}
```
### [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/)
```java
class Solution {
    public List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        dfs(1, k, n, new ArrayList<>());
        return res;
    }
    public void dfs(int i, int k, int n, List<Integer> curr){
        if(k == 0){
            if(n == 0){
                res.add(new ArrayList<>(curr));
            }
            return;
        }
        if (i > 9 || i < 1){
            return;
        }
        curr.add(i);
        dfs(i+1, k-1, n-i, curr);
        curr.remove(curr.size() - 1);
        dfs(i+1, k, n, curr);
    }
}
```
