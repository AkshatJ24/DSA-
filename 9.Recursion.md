# Recursion
## DAY 55
### [Implement Pow(x,n)](https://leetcode.com/problems/powx-n/description/)
```java
class Solution {
    public double myPow(double x, int n) {
        return Math.pow(x,n);
    }
}
```
```java
class Solution {
    public double myPow(double x, int n) {
        // Handle negative exponents by inverting x and making n positive.
        // We use a long to store 'n' to safely handle the edge case 
        // when n is Integer.MIN_VALUE (-2,147,483,648), which has no positive counterpart 
        // in an 'int' (Integer.MAX_VALUE is only 2,147,483,647).
        long N = n; 
        
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }

        double result = 1.0;
        double currentProduct = x;
        
        // Loop while the exponent N is greater than 0
        while (N > 0) {
            
            // If the last bit of N is 1 (i.e., N is odd)
            // This means we need to multiply the result by the current power of x
            if ((N & 1) == 1) { 
                result = result * currentProduct;
            }
            
            // Square the current product for the next iteration
            // This is the "squaring" part of the algorithm
            currentProduct = currentProduct * currentProduct;
            
            // Halve the exponent (equivalent to N = N / 2)
            N = N >> 1; 
        }
        
        return result;
    }
}
```
## DAY 56
### [Count Good Numbers](https://leetcode.com/problems/count-good-numbers/description/)
```java
class Solution {
    static final int MOD = 1_000_000_007;

    public int countGoodNumbers(long n) {
        return (int) (countGoodNumbersRecursive(n, 0) % MOD);
    }

    private long countGoodNumbersRecursive(long n, long currentIndex) {
        if (currentIndex == n) {
            return 1;
        }
        
        long result = 0;
        
        if (currentIndex % 2 == 0) {
            result = (5 * countGoodNumbersRecursive(n, currentIndex + 1));
        } else { 
            result = (4 * countGoodNumbersRecursive(n, currentIndex + 1));
        }

        return result % MOD;
    }
}
```
#### Optimized Approach
```java
class Solution {
    private final int MOD = 1_000_000_007;

    public int countGoodNumbers(long n) {
        long countOfFives = (n + 1) / 2; 
        long countOfFours = n / 2;

        long resultFive = power(5, countOfFives);
        long resultFour = power(4, countOfFours);

        return (int) ((resultFive * resultFour) % MOD);
    }

    private long power(long base, long exponent) {
        long result = 1;
        base %= MOD; 

        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % MOD;
            }
            base = (base * base) % MOD;
            exponent /= 2;
        }
        return result;
    }
}
```
## DAY 57
### [Generate Paranthesis](https://leetcode.com/problems/generate-parentheses/description/)
```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        backtrack("",0,0,n,res);
        return res;
    }
    static void backtrack(String s, int open, int close, int n, List<String> res){
        if(s.length() == 2 * n){
            res.add(s);
            return;
        }
        if(open < n){
            backtrack(s + "(",open + 1, close, n, res);
        }
        if(close < open) {
            backtrack(s + ")",open , close + 1, n, res);
        }
    }
}
```
## DAY 58
### [Subsets](https://leetcode.com/problems/subsets/description/)
```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    
    private List<List<Integer>> result;
    
    public List<List<Integer>> subsets(int[] nums) {
        this.result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        solve(0, nums, currentSubset); 
        return this.result;
    }
    
    private void solve(int i, int[] nums, List<Integer> currentSubset) { 
        
        if (i == nums.length) {
            this.result.add(new ArrayList<>(currentSubset)); 
            return;
        }
        
        // PICK
        currentSubset.add(nums[i]);
        solve(i + 1, nums, currentSubset);
        
        // BACKTRACK
        currentSubset.remove(currentSubset.size() - 1);
        
        // DON'T PICK
        solve(i + 1, nums, currentSubset);
    }
}
```
