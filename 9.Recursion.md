# Recursion
## DAY 55
### [Implement Pow(x,n)](https://leetcode.com/problems/powx-n/description/)
```java
class Solution {
    public double myPow(double x, int n) {
        return Math.pow(x,n);
    }
}
```
```java
class Solution {
    public double myPow(double x, int n) {
        // Handle negative exponents by inverting x and making n positive.
        // We use a long to store 'n' to safely handle the edge case 
        // when n is Integer.MIN_VALUE (-2,147,483,648), which has no positive counterpart 
        // in an 'int' (Integer.MAX_VALUE is only 2,147,483,647).
        long N = n; 
        
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }

        double result = 1.0;
        double currentProduct = x;
        
        // Loop while the exponent N is greater than 0
        while (N > 0) {
            
            // If the last bit of N is 1 (i.e., N is odd)
            // This means we need to multiply the result by the current power of x
            if ((N & 1) == 1) { 
                result = result * currentProduct;
            }
            
            // Square the current product for the next iteration
            // This is the "squaring" part of the algorithm
            currentProduct = currentProduct * currentProduct;
            
            // Halve the exponent (equivalent to N = N / 2)
            N = N >> 1; 
        }
        
        return result;
    }
}
```
