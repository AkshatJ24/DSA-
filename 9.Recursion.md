# Recursion
## DAY 55
### [Implement Pow(x,n)](https://leetcode.com/problems/powx-n/description/)
```java
class Solution {
    public double myPow(double x, int n) {
        return Math.pow(x,n);
    }
}
```
```java
class Solution {
    public double myPow(double x, int n) {
        // Handle negative exponents by inverting x and making n positive.
        // We use a long to store 'n' to safely handle the edge case 
        // when n is Integer.MIN_VALUE (-2,147,483,648), which has no positive counterpart 
        // in an 'int' (Integer.MAX_VALUE is only 2,147,483,647).
        long N = n; 
        
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }

        double result = 1.0;
        double currentProduct = x;
        
        // Loop while the exponent N is greater than 0
        while (N > 0) {
            
            // If the last bit of N is 1 (i.e., N is odd)
            // This means we need to multiply the result by the current power of x
            if ((N & 1) == 1) { 
                result = result * currentProduct;
            }
            
            // Square the current product for the next iteration
            // This is the "squaring" part of the algorithm
            currentProduct = currentProduct * currentProduct;
            
            // Halve the exponent (equivalent to N = N / 2)
            N = N >> 1; 
        }
        
        return result;
    }
}
```
## DAY 56
### [Count Good Numbers](https://leetcode.com/problems/count-good-numbers/description/)
```java
class Solution {
    static final int MOD = 1_000_000_007;

    public int countGoodNumbers(long n) {
        return (int) (countGoodNumbersRecursive(n, 0) % MOD);
    }

    private long countGoodNumbersRecursive(long n, long currentIndex) {
        if (currentIndex == n) {
            return 1;
        }
        
        long result = 0;
        
        if (currentIndex % 2 == 0) {
            result = (5 * countGoodNumbersRecursive(n, currentIndex + 1));
        } else { 
            result = (4 * countGoodNumbersRecursive(n, currentIndex + 1));
        }

        return result % MOD;
    }
}
```
#### Optimized Approach
```java
class Solution {
    private final int MOD = 1_000_000_007;

    public int countGoodNumbers(long n) {
        long countOfFives = (n + 1) / 2; 
        long countOfFours = n / 2;

        long resultFive = power(5, countOfFives);
        long resultFour = power(4, countOfFours);

        return (int) ((resultFive * resultFour) % MOD);
    }

    private long power(long base, long exponent) {
        long result = 1;
        base %= MOD; 

        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % MOD;
            }
            base = (base * base) % MOD;
            exponent /= 2;
        }
        return result;
    }
}
```
## DAY 57
### [Generate Paranthesis](https://leetcode.com/problems/generate-parentheses/description/)
```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        backtrack("",0,0,n,res);
        return res;
    }
    static void backtrack(String s, int open, int close, int n, List<String> res){
        if(s.length() == 2 * n){
            res.add(s);
            return;
        }
        if(open < n){
            backtrack(s + "(",open + 1, close, n, res);
        }
        if(close < open) {
            backtrack(s + ")",open , close + 1, n, res);
        }
    }
}
```
## DAY 58
### [Subsets](https://leetcode.com/problems/subsets/description/)
```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    
    private List<List<Integer>> result;
    
    public List<List<Integer>> subsets(int[] nums) {
        this.result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        solve(0, nums, currentSubset); 
        return this.result;
    }
    
    private void solve(int i, int[] nums, List<Integer> currentSubset) { 
        
        if (i == nums.length) {
            this.result.add(new ArrayList<>(currentSubset)); 
            return;
        }
        
        // PICK
        currentSubset.add(nums[i]);
        solve(i + 1, nums, currentSubset);
        
        // BACKTRACK
        currentSubset.remove(currentSubset.size() - 1);
        
        // DON'T PICK
        solve(i + 1, nums, currentSubset);
    }
}
```
## DAY 59
### [Combination Sum](https://leetcode.com/problems/combination-sum/description/)
```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        dfs(0, new ArrayList<>(), 0, candidates, target);
        return res;
    }
    private void dfs(int i, List<Integer> cur, int total, int[] candidates, int target) {   
        if (total == target) {
            res.add(new ArrayList<>(cur));
            return;
        }
        if (i >= candidates.length || total > target) {
            return;
        }
        // PICK
        cur.add(candidates[i]);
        dfs(i, cur, total + candidates[i], candidates, target);
        cur.remove(cur.size() - 1);
        // DON'T PICK
        dfs(i + 1, cur, total, candidates, target);
    }
}
```
## DAY 60
### [Subsets II](https://leetcode.com/problems/subsets-ii/description/)
```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        findSubsets(0, nums, new ArrayList<>(), ans);
        return ans;
    }
    public static void findSubsets(int ind, int[] nums, List<Integer> ds, List<List<Integer>> ans){
        ans.add(new ArrayList<>(ds));
        for(int i = ind; i < nums.length; i++){
            if(i!=ind && nums[i] == nums[i-1]) continue; 
            ds.add(nums[i]); 
            findSubsets(i+1, nums, ds, ans); 
            ds.remove(ds.size() - 1);
        }
    }
}
```
## DAY 61 
### [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/description/)
```java
class Solution {
    
    private List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        dfs(0, new ArrayList<>(), 0, candidates, target);
        return res;
    }

    private void dfs(int i, List<Integer> cur, int total, int[] candidates, int target) {
        
        if (total == target) {
            res.add(new ArrayList<>(cur));
            return;
        }

        if (i >= candidates.length || total > target) {
            return;
        }

        // PICK
        cur.add(candidates[i]);
        dfs(i + 1, cur, total + candidates[i], candidates, target);
        cur.remove(cur.size() - 1);
        
        while(i+1 < candidates.length && candidates[i] == candidates[i+1]) ++i;

        // DON'T PICK
        dfs(i + 1, cur, total, candidates, target);
    }
}
```
### [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/)
```java
class Solution {
    public List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        dfs(1, k, n, new ArrayList<>());
        return res;
    }
    public void dfs(int i, int k, int n, List<Integer> curr){
        if(k == 0){
            if(n == 0){
                res.add(new ArrayList<>(curr));
            }
            return;
        }
        if (i > 9 || i < 1){
            return;
        }
        curr.add(i);
        dfs(i+1, k-1, n-i, curr);
        curr.remove(curr.size() - 1);
        dfs(i+1, k, n, curr);
    }
}
```
## DAY 62
### [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)
```java
class Solution {
    public List<String> letterCombinations(String digits) {
        if(digits == null || digits.length() == 0) return new ArrayList<>();

        String[] mapping = {"",    // 0
            "",    // 1
            "abc", // 2
            "def", // 3
            "ghi", // 4
            "jkl", // 5
            "mno", // 6
            "pqrs",// 7
            "tuv", // 8
            "wxyz" // 9
        };
        List<String> result = new ArrayList<>();
        backtrack(digits, 0, new StringBuilder(), mapping, result);
        return result;
    }
    private static void backtrack(String digits, int index, StringBuilder current, String[] mapping, List<String> result){
        if(index == digits.length()){
            result.add(current.toString());
            return;
        }
        String letters = mapping[digits.charAt(index) - '0'];
        for(char letter : letters.toCharArray()){
            current.append(letter);
            backtrack(digits, index + 1, current, mapping, result);
            current.deleteCharAt(current.length() - 1);
        }
    }
}
```
## DAY 62
### [Palindrome Partitionig](https://leetcode.com/problems/palindrome-partitioning/description/)
```java
class Solution {
    private boolean isPalindrome(String s, int start, int end){
        while(start < end){
            if(s.charAt(start) != s.charAt(end)) return false;
            start++;
            end--;
        }
        return true;
    }
    private void backtrack(int index, String s, List<String> path, List<List<String>> res){
        if(index == s.length()){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = index; i < s.length(); i++){
            if(isPalindrome(s,index,i)){
                path.add(s.substring(index,i+1));
                backtrack(i+1, s, path, res);
                path.remove(path.size()-1);
            }
        }
    }
    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<>();
        List<String> path = new ArrayList<>();
        backtrack(0,s,path,res);
        return res;
    }
}
```
## DAY 62
### [Word Search](https://leetcode.com/problems/word-search/description/)
```java
class Solution {
    private int ROWS;
    private int COLS;
    public boolean exist(char[][] board, String word) {
        if (board.length == 0 || word.length() == 0) return false;
        
        ROWS = board.length;
        COLS = board[0].length;
        for (int r = 0; r < ROWS; r++) {
            for (int c = 0; c < COLS; c++) {
                if (dfs(0, r, c, new HashSet<String>(), word, board)) {
                    return true;
                }
            }
        }
        return false;
    }
    private boolean dfs(int index, int r, int c, HashSet<String> path, String word, char[][] board) {
        if (index == word.length()) {
            return true;
        }
        String cellKey = r + "," + c;
        if (r < 0 || r >= ROWS || c < 0 || c >= COLS || 
            word.charAt(index) != board[r][c] || 
            path.contains(cellKey)) {
            return false;
        }
        path.add(cellKey);
        boolean res = dfs(index + 1, r + 1, c, path, word, board) || // Down
                      dfs(index + 1, r - 1, c, path, word, board) || // Up
                      dfs(index + 1, r, c + 1, path, word, board) || // Right
                      dfs(index + 1, r, c - 1, path, word, board);  // Left

        path.remove(cellKey);
        
        return res;
    }
}
```
## DAY 63
### [N Queens](https://leetcode.com/problems/n-queens/description/)
```java
class Solution {

    private List<String> construct(char[][] board, int n) {
        List<String> temp = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            temp.add(new String(board[i]));
        }
        return temp;
    }

    public boolean isSafe(int row, int col, char[][] board, int n) {
        
        int r = row;
        int c = col;

        for (int j = 0; j < col; j++) {
            if (board[row][j] == 'Q') return false;
        }

        r = row; c = col;
        while (r >= 0 && c >= 0) {
            if (board[r][c] == 'Q') return false;
            r--;
            c--;
        }

        r = row; c = col;
        while (r < n && c >= 0) {
            if (board[r][c] == 'Q') return false;
            r++;
            c--;
        }

        return true;
    }

    public void solve(int col, char[][] board, List<List<String>> ans, int n) {
        if (col == n) {
            ans.add(construct(board, n));
            return;
        }

        for (int row = 0; row < n; row++) {
            if (isSafe(row, col, board, n)) {
                board[row][col] = 'Q';
                solve(col + 1, board, ans, n);
                board[row][col] = '.';
            }
        }
    }

    public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
        char[][] board = new char[n][n];
        
        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i], '.');
        }
        
        solve(0, board, ans, n);
        return ans;
    }
}
```
## DAY 65
### [N Queens](https://leetcode.com/problems/n-queens/description/)
```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> res = new ArrayList<>();
        
        Set<Integer> col = new HashSet<>();
        Set<Integer> posDiag = new HashSet<>(); 
        Set<Integer> negDiag = new HashSet<>(); 
        
        char[][] board = new char[n][n]; 
        for(int i = 0; i < n; i++){
            Arrays.fill(board[i], '.');
        }
        
        backtrack(n, res, col, posDiag, negDiag, board, 0); 
        return res;
    }

    private List<String> convertBoard(char[][] board){
        List<String> solution = new ArrayList<>();
        for(char[] row : board){
            solution.add(new String(row));
        }
        return solution;
    }

    public void backtrack(int n, List<List<String>> res, 
                          Set<Integer> col, Set<Integer> posDiag, 
                          Set<Integer> negDiag, char[][] board, int r){
        
        if(r == n){
            res.add(convertBoard(board));
            return;
        }
        
        for(int c = 0; c < n; c++){
            if(col.contains(c) || posDiag.contains(r + c) || negDiag.contains(r - c)){
                continue; 
            }
            col.add(c);
            posDiag.add(r + c);
            negDiag.add(r - c);
            board[r][c] = 'Q';

            backtrack(n, res, col, posDiag, negDiag, board, r + 1);

            col.remove(c);
            posDiag.remove(r + c);
            negDiag.remove(r - c);
            board[r][c] = '.';
        }
    }
}
```
## DAY 68
### [Sudko Solver](https://leetcode.com/problems/sudoku-solver/description/)
```java
class Solution {
    public void solveSudoku(char[][] board) {
        solve(board);
    }
    public static boolean solve(char[][] board){
        for(int i = 0; i < 9; i++){
            for(int j = 0; j < 9; j++){
                if(board[i][j] == '.'){
                    for(char c = '1'; c <= '9'; c++){
                        if(isValid(board, i, j, c)){
                            board[i][j] = c;
                            if(solve(board) == true){
                                return true;
                            } else{
                                board[i][j] = '.';
                            }
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    public static boolean isValid(char[][] board, int row, int col, char c){
        for(int i = 0; i < 9; i++){
            if(board[i][col] == c) return false;
            if(board[row][i] == c) return false;
            if(board[3 * (row/3) + i/3][3 * (col/3) + i%3] == c) return false;
        }
        return true;
    }
}
```
