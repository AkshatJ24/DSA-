# 3. Binary Search
## Day 11

### Binary Search
#### Recursive Approach
```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int low = 0;
        int high = n - 1;
        return binarysearch(nums, low, high, target); 
    }

    public int binarysearch(int[] nums, int low, int high, int target) {
        if (low > high) {
            return -1;
        }
        
        int mid = low + (high - low) / 2; 

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] > target) { 
            return binarysearch(nums, low, mid - 1, target);
        } else { 
            return binarysearch(nums, mid + 1, high, target);
        }
    }
}
```
#### Iterative Approach
```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int low = 0;
        int high = n-1;
        
        while(low <= high){
            int mid = (low + high) / 2;
            if(nums[mid] == target){
                return mid;
            } else if (target > nums[mid]){
                low = mid + 1;
            } else {
                high = mid-1;
            }
        }
        return -1;
    }
}
```
### Lower Bound (Search Insert Position)
```java
import java.util.*;

public class Solution {

    public static int lowerBound(int []arr, int n, int x) {
        int low = 0, high = n - 1;
        int ans = n;

        while (low <= high) {
            int mid = (low + high) / 2;
            // maybe an answer
            if (arr[mid] >= x) {
                ans = mid;
                //look for smaller index on the left
                high = mid - 1;
            } else {
                low = mid + 1; // look on the right
            }
        }
        return ans;
    }
```

### Upper Bound
```java
import java.util.*;

public class tUf {

    public static int upperBound(int[] arr, int x, int n) {
        int low = 0, high = n - 1;
        int ans = n;

        while (low <= high) {
            int mid = (low + high) / 2;
            // maybe an answer
            if (arr[mid] > x) {
                ans = mid;
                //look for smaller index on the left
                high = mid - 1;
            } else {
                low = mid + 1; // look on the right
            }
        }
        return ans;
    }
```

## Day 12
### First and Last occuernce of an Element in array {Using Binary Search}
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length;
        int[] result = new int[2];
        int first = -1;
        int last = -1;

        int low = 0;
        int high = n - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] == target) {
                first = mid;
                high = mid - 1;
            } else if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        result[0] = first;

        low = 0;
        high = n - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] == target) {
                last = mid;
                low = mid + 1;
            } else if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        result[1] = last;

        return result;
    }
}
```

### Find occurences of an array in element
```java
//import java.util.*;
class Solution {
    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {
        HashMap<Integer,Integer> map= new HashMap<>();
        int count = 0;
        int n = nums.length;

        for(int i=0; i<n ; i++){
            if(nums[i] == x){
                count++;
                map.put(count,i);
            }
        }
        for(int i=0; i<queries.length; i++){
            if(map.containsKey(queries[i])){
                queries[i] = map.get(queries[i]);
            } else {
                queries[i] = -1;
            }
        }
        return queries;
    }
}
```
## DAY 13
### Count Occurences in an Array using BS
```java
class Solution {
    public int[] SearchOccurences(int[] nums, int target) {
        int n = nums.length;
        int first = -1;
        int last = -1;

        int low = 0;
        int high = n - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] == target) {
                first = mid;
                high = mid - 1;
            } else if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        low = 0;
        high = n - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] == target) {
                last = mid;
                low = mid + 1;
            } else if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return (first + last - 1);
    }
}
```
### Search in rotated Sorted Array I
```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int low = 0;
        int high = n - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (nums[mid] == target) {
                return mid;
            }

            if (nums[low] <= nums[mid]) {
                if (nums[low] <= target && target < nums[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } 
            else {
                if (nums[mid] < target && target <= nums[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        
        return -1;
    }
}
```
## DAY 14
### Search in Rotated Sorted Array II
```java
class Solution {
    public boolean search(int[] nums, int target) {
        int n= nums.length;
        int low = 0;
        int high = n-1;

        while(low<=high){
            int mid = (low+high)/2;
            if(nums[mid] == target){
                return true;
            }
            if(nums[low] == nums[mid] && nums[high] == nums[mid]){
                low = low + 1;
                high = high - 1;
                continue;
            }
            if(nums[low] <= nums[mid]){
                if(nums[low] <= target && nums[mid] >= target){
                    high = mid - 1;
                } else{
                    low = mid + 1;
                }
            } else {
                if(nums[mid] <= target && nums[high] >= target){
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        return false;
    }
}
```
