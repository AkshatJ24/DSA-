# Stack & Queues
## DAY 24
#### Implement Stack as Queue
```java
class MyStack {

    Queue <Integer> q;
    
    public MyStack() {
        q = new LinkedList<>();
    }
    
    public void push(int x) {
        q.add(x);
        for(int i = 0; i < q.size()-1 ; i++){
            q.add(q.remove());
        }
    }
    
    public int pop() {
        return q.remove();
    }
    
    public int top() {
        return q.peek();
    }
    
    public boolean empty() {
        if(q.size() == 0){
            return true;
        } else {
            return false;
        }
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
 ```
## DAY 25
### Implement Queue using Stack
```java
class MyQueue {
    Stack<Integer> input;
    Stack<Integer> output;

    public MyQueue() {
        input = new Stack<>();
        output = new Stack<>();
    }

    public void push(int x) {
        input.push(x);
    }

    public int pop() {
        if (output.empty()) {
            while (!input.empty()) {
                output.push(input.pop());
            }
        }
        return output.pop();
    }

    public int peek() {
        if (output.empty()) {
            while (!input.empty()) {
                output.push(input.pop());
            }
        }
        return output.peek();
    }

    public boolean empty() {
        return input.empty() && output.empty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```
## DAY 26
### Check for Balanced Parentheses
```java
class Solution {
    public boolean isValid(String s) {
        Stack <Character> st = new Stack<Character>();
        for(char it : s.toCharArray()){
            if(it == '(' || it == '[' || it == '{'){
                st.push(it);
            }
            else{
                if(st.isEmpty()){
                    return false;
                }
                char ch = st.peek();
                st.pop();
                if( (ch == ')' && ch == '(') ||
                    (ch == ']' && ch == '[') ||
                    (ch == '}' && ch == '{')){
                        continue;
                } else {
                    return false;
                }
            }
        }
        return st.isEmpty();
    }
}
```
### Implement MIN Stack
```java
class Pair {
    int x, y; // x = value, y = current min
    Pair(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class MinStack {
    Stack<Pair> st;

    public MinStack() {
        st = new Stack<>();
    }

    public void push(int val) {
        int min = st.isEmpty() ? val : Math.min(val, st.peek().y);
        st.push(new Pair(val, min));
    }

    public void pop() {
        st.pop();
    }

    public int top() {
        return st.peek().x;
    }

    public int getMin() {
        return st.peek().y;
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

### Next Greater Elements
```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        Stack<Integer> st = new Stack<>();

        for (int i = 2 * n - 1; i >= 0; i--) {
            int curr = nums[i % n];
            while (!st.isEmpty() && st.peek() <= curr) {
                st.pop();
            }

            if (i < n) {
                ans[i] = st.isEmpty() ? -1 : st.peek();
            }

            st.push(curr);
        }

        return ans;
    }
}
```
